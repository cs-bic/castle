# Castle

## Synopsis

Castle is a symmetric cryptosystem that is upgradeable through changing which hashing algorithm, size of key, size of nonce, or amount of padding you give it.

## Specification

### Encryption

1. A digest of the data is produced via the provided hashing algorithm, encoded using Base 64, and then prepended to the data with a trailing period.
2. The data is padded via Paddle according to the block size.
3. The key is hashed with the nonce as a salt, and the resulting digest is then used to begin a chain of digests, where each odd and even pair are double XOR-ed against the appropriate section of the data. Every required digest after the initial one is generated by hashing the previous digest.
4. The nonce is prepended to the data.

### Decryption

Reversal of the steps for encryption are commited upon the ciphertextâ€”the same hashing algorithm, key, and size of nonce must be provided.

## Distribution

Castle is released as a package written in [Go](https://golang.org) under the MIT License. Castle is currently at version 1.0.0, and will likely undergo an update that adds a constant-time implementation in order to be resistant to side-channel attacks.

## Example

```
package main
import (
	"crypto/sha512"
	"fmt"
	"github.com/cs-bic/castle"
)
func main() {
	block := 100
	data := []byte("Attack the ship at midnight!")
	hasher := func(data []byte) ([]byte, error){
		digest := sha512.Sum512(data)
		return digest[:], nil
	}
	key := []byte("This should be randomly generated.")
	nonce := []byte("This should be randomly generated.")
	fmt.Println("ORIGINAL LENGTH: ", len(data))
	fmt.Println("ORIGINAL: ", data)
	data, issue := castle.Encrypt(block, data, hasher, key, nonce)
	if issue != nil {
		panic(issue)
	}
	fmt.Println("ENCRYPTED LENGTH: ", len(data))
	fmt.Println("ENCRYPTED: ", data)
	data, issue = castle.Decrypt(data, hasher, key, len(nonce))
	if issue != nil {
		panic(issue)
	}
	fmt.Println("DECRYPTED LENGTH: ", len(data))
	fmt.Println("DECRYPTED: ", data)
}
```
